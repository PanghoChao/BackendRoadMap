# 자료구조 Heap
- 힙은 **최대값 및 최솟값을 찾아내는 연산**을 빠르게 하기 위해 고안된 **완전 이진트리**를 기본으로 한 자료구조이다.
- 부모노드와 자식노드는 항상 키값으로 대소관계가 성립된다. 
- 힙의 종류로는 2가지가 있다.
  - 최대 힙 : 항상, 부모노드의 키값 > 자식노드의 키값     
  - 최소 힙 : 항항, 부모노드의 키값 < 자식노드의 키값
- 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 특히 **형제 사이에는 대소관계가 정해지지 않는다.**
<p align =center><img src="/images/4.ProgrammingLanguage/1.Java/dataStructure/Heap_binaryHeap.png" width = 60%></p>

> `메모리`에도 `힙(Heap)` 이라는 명칭이 존재하지만, `자료구조` `힙(Heap)`과는 무관하니, 헤깔리지 않아야한다.

- 자료구조 힙(Heap)과 자료구조 큐(Queue)를 합친 자료형이 `우선순위 큐(priority Queue)`이다.

## 이진힙(binary Heap)
> 각 노드의 자식 노드의 최대개수는 힙의 종류에 따라 다르지만, 대부분 최대 자식노드가 2개인 `이진힙(binary heap)`을 사용한다.    

.  
내부노드에 키와 요소를 저장한 이진트리로 다음과 같은 두가지 특징을 갖는다. 
  - 트리를 T, 임의 내부노드를 v 라고 하면 다음과 같다
    1. 뿌리노드를 제외한 각 내부노드는 key(T.parent(v)) < key(v) 또는 key(T.parent(v)) > key(v)이다. (즉, 키 값은 오름차순이거나 내림차순이다.)
    2. 마지막 왼쪽 결합 노드들의 레벨을 제외한 다른 모든 레벨들은 완전 이진트리를 형성한다. 
 - 힙 리스트(heap list)로 표현할 때 i번째 노드의 왼쪽 자식노드의 위치는 2i가 되며, i번째 노드의 오른쪽 자식노드의 위치는 2i+1이고, 또한 i번째 노드의 부모노드의 위치는 i/2가 된다.    

말이 어렵게되어 있어서 그렇지 그림으로 표현하면 아래와 같다.   
<img src="/images/4.ProgrammingLanguage/1.Java/dataStructure/Heap_config.png">

### 시간복잡도
- 힙의 시간복잡성은 O(log n) 이다


## 구현
먼저 수도코드로 작성해보았다.
- 뿌리 노드(즉, Root노드)는 제외하고 나머지는 부모와 자식이 비교하여 결론을 내야한다. 
- 뿌리 노드의 경우 부모노드가 없으므로 제외하는 것

### 최대힙 수도코드
```
public maxHeap(Position v){ // 
    while(not is뿌리(v) && key(parent(v)) < key(v)){//뿌리 노드가 아니여야하고 v 이 부모보다 커야된다.
        swap항목(v, parent(v)); // 부모와 자식의 위치를 바꾼다.
        v = parent(v); // v가 또다시 부모보다 클수 있기에
    }
}
```
물론 부모와 자식이라는 표현대신에, i(자식) 와 i/2(부모)로도 가능하다. 

```
public maxHeap(int i){ // 
    while( (i != 0) && key(i/2) < key(i)){
        swap(i, i/2); 
        i = i/2; 
    }
}
```



### 최소힙 수도코드 
- 최소힙의 경우는 그 반대로 해주면 된다. 
```
public minHeap(int i){ // 
    while( (i != 0) && key(i/2) > key(i)){ //부모가 더 크면 
        swap(i, i/2); // 위치 바꾸고
        i = i/2; //
    }
}
```




참고링크  [위키백과참조](https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0))
